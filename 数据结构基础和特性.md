# 数据结构的特性

### 数组，链表，跳表
1. Array 数组
    - 优缺点：
        - 随机的访问任何一个元素，访问速度快，为`O(1)`;
        - 删除，插入操作复杂不高效，时间复杂度为 `O(n)`
2. Linked List 链表
    - 头节点为head，尾指针为tail，最后的一个指针的next为null;
    - 单链表（next），双链表(next, prev)，循环链表;
    - 优缺点: 
        - 删除和修改的及节点的效率特别高， 为`O(1)`；
        - 访问操作，需要从头节点一步一步的往后挪，时间复杂为`O(n)`;
    
3. Skip List跳表
    - 如何给了链表进行加速
        - 升维，空间换时间，
    - 添加第一级索引....多级索引
        - 空间换时间的一种策略, 空间复杂度O(n)
        - <img src="https://static.prnasia.com/pro/gift/skiplist.png" width="60%"/>
    - 跳表的查询的时间复杂度的分析
    	- **n/2，n/4，n/8，第K级索引的节点的个数就是`n/(2^k)`**
    	- **假设索引有h级，最高级的索引有2个节点，`n/(2^h)=2`,从而求得`h=log2(n)-1`;**
    	- <img src="https://static.prnasia.com/pro/gift/runtime.png" width="60%"/>
    - 优缺点
        - 索引由于增加删除，可能不工整，有的可能少步，有的可能多步
        - 添加删除维护成本较高，每次添加一个需要把索引更新一遍。
4. 时间复杂度对比
    | 时间复杂度 | Array数组| Linked List链表| skip List跳表|
    |:-----:| :-----:| :-----:| :-----: |
    | prepend | O(1) | O(1)| - |
    | append | O(1)	| O(1)| - |
    | lookup | O(1)	| O(n)| O(logn) |
    | insert | O(n)	| O(1)| - |
    | delete | O(n)	| O(1)| - |
### 栈 队列 优先队列 双端队列 (Stack Queue)
> 具体的实现都是用途数组进行一个模拟
> google怎么查询java的相管的具体实现。
>> 1.直接搜 stack javascript 2.搜源码实现 stack javascript source
1. Stack FILO 栈尾删除添加操作
    - 先入后出；添加,删除皆为O(1),查询O(n);
    - https://juejin.im/entry/59c8a0a2f265da0659432aa2
2. Queue FIFO   队首删除，队尾添加
    - 先入先出；添加，删除皆为O(1),查询O(n);
    - https://juejin.im/entry/59c9c3c86fb9a00a4f1b3e51
3. Deque (Double-End-Queue双端队列)
    - 对首添加删除元素，队尾添加删除元素
    - 插入删除都是O(1), 查询是O(n)
4. Priority Queue(优先队列)
    - 插入操作O(1), 
    - 取出操作O(logN)按照元素的优先级取出
    - 底层具体实现的数据结构较为多样和复杂： heap bst treap

```javascript
//stack
 class Stack{
     constructor(){
         this.items = [];
         this.top = 0;
     }
     push(element){
         //入栈
         this.items[this.top++] = element;
     }
     pop(){
         //出栈
         return this.items[--this.top];
     }
     peek(){
         //查看栈顶元素
         if(this.top>0){
             return this.items[this.top-1];
         }else{
             return 'Empty';
         }
     }
     length(){
         return this.top;
     }
     clear(){
         delete this.items;
         this.items= [];
         this.top = 0;
     }
 }
 //后缀表达式 postFixEvaluation("235*+8-")
 function postFixEvaluation(exp){
     let stack = new stack();
     for(let i=0;i<exp.length;i++){
         let c = exp[i];
         if(!isNaN(c)){
             stack.push(c-'0');
         }else{
             let val1 = stack.pop(), val2 = stack.pop();
             if(val1 == 'Underflow'||val2=="Underflow"){
                 return "can't perfrom postfix evaluation"
             }
             switch(c){
                case "+":""
                    stack.push(val2+val1);
                    break;
                case "-":
                    stack.push(val2-val1);
                    break;
                case "/" :   
                    stack.push(val2/val1);
                    break;
                case "*":
                    stack.push(val2*val1)
                    break;
             }
         }
     }
     return stack.pop();
 }
```
### 哈希表，映射，集合
1. Hash table
    - 哈希表，也叫散列表，是根据关键码值（key value）而直接进行访问的数据结构
    - 它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度，
    - 这个映射函数叫做散列函数，存放记录的数组叫做哈希表；
    - 哈希碰撞，如果碰撞的很多那么链表会很长，查询速度可能退化为链表O(n)，如果哈希设计的效率很高，那么查询是O(1);
    - 工程实践：
        - 电话号码簿  用户信息表  缓存  键值对存储 
2. Set Map
    
### 树 二叉树  二叉搜索树
1. 
2. 
