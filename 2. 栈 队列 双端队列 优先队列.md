# Stack Queue Deque Priority
# Stack 栈
### 1. 20. 有效的括号
1. 链接：https://leetcode-cn.com/problems/valid-parentheses/
2. 描述：给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。
    - 有效字符串需满足：
        - 左括号必须用相同类型的右括号闭合。
        - 左括号必须以正确的顺序闭合。
        - 注意空字符串可被认为是有效字符串。
3. 示例:
    ```javascript
    示例 1:
    输入: "()"
    输出: true
    示例 2:
    输入: "()[]{}"
    输出: true
    示例 3:
    输入: "(]"
    输出: false
    示例 4:
    输入: "([)]"
    输出: false
    示例 5:
    输入: "{[]}"
    输出: true
    ```
4. 题解：
    1. 暴力求解
        - 不断的replace匹配的括号为 => ''; ()[]{} (({[]}));
        - 时间复杂度为 O(n^2);
    2. 栈求解
        - 最近相关性就考虑用栈
        - 跟栈顶元素匹配上一对就出栈抵消，不是一对就压到栈里面，看最后栈内元素是否为空；
    ```javascript   
    var isValid = function(s){
        let s1 = s;
        while(s.length){
            s.replace(/(\{\}|\(\)|\[\])/,'');
            if(s1 == s){
                return false;
            }
            s1 = s;
        }
        return true;
    }
    var isValid = function (s){
        let dic = {'}':'{', ']':'[',')':'('},
            stack = new Stack()
        for(let i=0;i<s.length;i++){
            dic[s[i]] == stack.peek()
            ? stack.pop(s[i]) 
            : stack.push(s[i]);
        }
        return stack.top?false:true;
    }
    ```
### 2. 84. 柱状图中最大的矩形
1. 链接：https://leetcode-cn.com/problems/largest-rectangle-in-histogram/
2. 描述：给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。
3. 示例:
    ```javascript   
    输入: [2,1,5,6,2,3]
    输出: 10
    ```
4. 题解：
    1. 暴力求解
        - 枚举以每个柱形为高度的最大矩形的面积。
        - 依次遍历柱形的高度，对于每一个高度分别向两边扩散，求出以当前高度为矩形的最大宽度多少。
        - 时间复杂度： O(n^2)
        - 空间复杂度：  O(1)
    2. 方法二：以空间换时间，用到的数据结构是栈
        - 这两个站在两边的柱形有一个很形象的名词，叫做哨兵（Sentinel）。
        - 这里栈对应到高度，呈单调增加不减的形态，因此称为单调栈（Monotone Stack）。它是暴力解法的优化，计算每个柱形的高度对应的最大矩形的顺序由出栈顺序决定。
        - 时间复杂度：O(N)，输入数组里的每一个元素入栈一次，出栈一次。
        - 空间复杂度：O(N)，栈的空间最多为 N。

    ```javascript
    //1.暴力
    /**
     * @param {number[]} heights
    * @return {number}
    */
    var largestRectangleArea = function (heights){
        let maxArea = 0,
            len = heights.length;
        //枚举高    
        for(let i=0;i<heights.length;i++){
            let l=i, r=i, h = heights[i];
            //确定左右的边界
            while(l>0&&heights[l-1]>=h){
                --l;
            }
            while(r<len-1&&heights[r+1]>=h){
                ++r;
            }
            //计算面积
            maxArea = Math.max(maxArea, h*(r-l+1));
        }
        return maxArea;
    } 
    //柱状图中最大的面积
    var largestRectangleArea = function (heights){
        if(heights.length<2){ 
            return heights.length?heights[0]:0;
        }
        heights.push(0);
        heights.unshift(0);
        let maxArea = 0,
            len = heights.length,
            stack = [-1,0];
            for(let i=1;i<len;i++){
                while(heights[stack[stack.length-1]] > heights[i]){
                    let h = stack.pop();
                    let w = i - stack[stack.length-1] -1;
                    maxArea = Math.max(maxArea, w*heights[h]);
                }
                stack.push(i);
            }
            return maxArea;
    }
    console.log(largestRectangleArea([1,3,4,5]));
    ```
# deque 双端队列
### 4. 239. 滑动窗口最大值
1. 链接：https://leetcode-cn.com/problems/sliding-window-maximum/
2. 描述：给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。返回滑动窗口中的最大值。
3. 示例:
    ```javascript   
    输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
    输出: [3,3,5,5,6,7] 
    ```
4. 题解：
    1. 暴力 
        - 枚举每个属性，选择中间最大值  
        - 复杂度 O(nk)
    2. 双端队列
        - 每个窗口看作一个队列，队列的头部放窗口中最大的值
        - 先把前K个队列计算出来，选出最大值
        - 之后继续向右枚举每个项，跟之前的队列作比较。
        -  时间复杂度：O(N)，每个元素被处理两次- 其索引被添加到双向队列中和被双向队列删除。
        - 空间复杂度：O(N)，输出数组使用了 O(N−k+1) 空间，双向队列使用了 O(k)。
    ```javascript
    var maxSlidingWindow = function(nums, k){
        if(!nums.length){
            return nums;
        }
        if(k == 1) return nums;
        let stack = [];
        for(let i=0;i<nums.length-k+1;i++){
            let max = nums[i];
            let j = i+1;
            while(j<k+i){
                max = Math.max(max, nums[j++]);
            }        
            stack.push(max);
        }
        return stack;
    }
    
    //2. 
    var maxSlidingWindow = function (nums, k){
        let len = nums.length;
        if(k==1){ return nums}
        let win = [], res = [];
        for(let i=0;i<k;i++){
            while(win.length!=0&&nums[i]>nums[win[win.length-1]]){
                win.pop();
            }
            win.push(i);
        }
        res.push(nums[win[0]]);
        for(i=k;i<len;i++){
            if(win.length!=0 && win[0]<=i-k){
                win.shift();
            }
            while(win.length!=0&&nums[i]>nums[win[win.length-1]]){
                win.pop();
            }
            win.push(i);
            res.push(nums[win[0]]);
        }
        return res;
    }


    maxSlidingWindow([5,1,3,4,6,9],3)
    ```
